## 스트림
- 데이터가 물 흐르듯 흘러가는것
- 한번 가면 끝임, 뒤로 돌아가는 기능은 보조스트림이 갖고 있음
- 입출력 통로가 각각 따로 있다

### InputStream, OutputStream
- Byte 단위로 데이터를 읽고 쓰는 것
- 추상메소드로 구현

### Reader, Writer

## 보조스트림
- readLine() : Buffered가 붙어있는 보조스트림
- 데이터를 한 문장씩 읽고 싶다.

### 장식
- InputStream, OutputStream, Reader, Writer 중 하나가 들어와야함
- IO는 주인공과 장식을 조합해서 사용하도록 설계되어있다
- 주인공 : 근원을 표기함 (어디서 읽을지, 어디에 쓸지)

### try-with-resource 
- try()안에는 closable을 구현한 객체만 들어갈 수 있다.

## 직렬화
- 데이터 줄세워서 이동, 도착하면 원래형태로 형변환

## SOLID 원칙 (객체지향의 5가지 원칙)

### Single Responsibility Principle (단일 책임 원칙)
- User 클래스의 setPassword 메소드에 비밀번호 검증 로직을 직접 넣는다면  검증 규칙이 수정될 때마다 User 클래스가 수정되어야함. 이게 맞나?
- PasswordValidator 클래스를 따로 만들어 놓으면 검증 로직이 변경된다고 해도 User는 수정할 필요가 없음
### Open/Closed Principle (개방-폐쇄 원칙)
- 기존 코드를 크게 수정하지 않고 기능 추가가 가능해야함
- 이미 잘 동작하는 로직을 보호, 버그나 리그레션(잘 되던게 수정이나 추가작업 후에 안되는 일) 방지
### Liskov Substitution Principle (리스코프 치환 원칙)
- 자식 클래스는 부모 클래스로 대체할 수 있어야 한다.
- 다형성의 장점을 살리고 코드 변경 시 오류 최소화
### Interface Segregation Principle (인터페이스 분리 원칙)
- 인터페이스는 클라이언트가 필요로 하는 기능만 제공
- 필요한 인터페이스를 분리, 불필요한 의존을 줄이는게 목적
### Dependancy Inversion Principle (의존성 역전 원칙)
- STV, LTV를 구현한 TV가 있으면 TVUser와 STV, LTV간의 결합도가 낮아짐
- STV, LTV가 바뀌어도 TVUser는 크게 영향을 받지 않음

## 객체지향의 핵심 개념
### 추상화
- 중요한 것만 남기는 것 (속성, 기능)
### 캡슐화
- 객체의 속성과 메소드르 하나의 단위로 묶고, 메소드를 통해서만 접근하도록 제한
### 상속
- 상위 클래스의 속성, 메소드를 하위 클래스가 물려받아 사용하는것
### 다형성
- 같은 메소드 호출이더라도 객체 타입에 따라 다른 동작을 수행

## 설계원칙의 존재 이유
- 코드 유지보수성 오름, 각 객체가 가진 책임이 분명해지고, 수정 범위 최소화
- 확장성 유연성 확보, 기존 코드를 크게 수정하지 않고도 확장 가능하도록 해야함
- 협업, 커뮤니케이션 원활