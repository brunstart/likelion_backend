## Set, List, Map 셋 전부 Interface
- set : 순서, 중복 없음  
- list : 가장 일반적, 순서, 중복 있음  
- map : 키-값 쌍으로 데이터를 저장, 검색이 빠름

## Collection / Collections
- Collection : 인터페이스
- Collections : 유틸리티 클래스

## Collections
- 자바의 표준 컬렉션 프레임워크에 포함된 클래스, 다양한 알고리즘, 정적 메서드 제공  
- 인스턴스화 불가한 클래스

### Collections의 메서드
- sort() : 정렬기능, Comparable interface를 구현한 객체만 정렬이 가능 compareTo 메서드 오버라이드 필요 (정렬 기준이 있어야 함)
  - sort는 바뀐게 없는데 들어오는 매개변수에 따라 동작하는게 달라짐 -> 다형성? (메소드 오버로딩도 다형성에 해당하는지)
  - 다형성 공부할 때는 makeSound를 Override한 Dog, Cat 객체에 따라 makeSound 결과값이 달라지는  
  걸 다형성이라고 했었는데 방금 sort는 메소드 오버로딩
  - 메소드 오버로딩도 다형성의 일종임, 오버라이딩을 통해서도 다형성 구현 가능

- shuffle()
```java
List<Integer> numbers = new ArrayList<Integer>();
for(int i = 0; i <= 10; i++)
{
    numbers.add(i);
}

Collections.shuffle(numbers);
System.out.println(numbers);    // [2, 1, 5, 7, 8, 4, 3, 6, 9, 0, 10]
```

## List에 Integer가 아니라 다른 객체가 들어갈 경우의 정렬 방법
예시) Person은 String name, int age 필드를 갖고 있는 클래스  
1. sort()에 들어갈 Comparator 클래스를 구현, 인스턴스 생성
```java
import java.util.Comparator;

public class PersonComparator implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
}
```
```java
Collections.sort(persons, new PersonComparator());      // 1번 방법
```
2. Comparator를 내부 클래스로 구현

```java
Comparator<Person> personCom = new Comparator<Person>() {   // 2번 방법
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
};

Collections.sort(persons, personCom);
```
3. Comparator를 익명 클래스로 구현
```java
Collections.sort(persons, new Comparator<Person>() {        // 3번 방법
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
});
```
### Comparable 인터페이스
- 객체의 기본 정렬 기준을 정의 -> compareTo() 메소드 구현
### Comparator 인터페이스
- 별도의 정렬 기준을 정의 -> compare() 메소드 구현

## 람다식
- 자바는 매개변수에 객체가 아닌 것들은 들어올 수 없다.
- 자바는 함수를 일급객체로 취급하지 않는다.
- 람다식의 장점 : 코드가 간결해진다.
```java
Collections.sort(persons, (o1, o2) -> o1.getAge() - o2.getAge());
// 보이는건 함수처럼 보이는데 실제 컴파일러가 구현한 객체를 만듬
```

## Generic
- 설계 당시에는 타입을 확정하지 않고, 생성 시에 타입을 결정하는것
- 자료구조 사용시 객체를 오브젝트로 받는데 하위 클래스의 객체를 받을 경우 해당 클래스의 메서드를  
사용하려면 일일이 형변환을 해줘야함. 이 때 <>안에 타입을 설정해주면 해당 타입의 객체만 받을 수 있게 됨.
- 형변환 없이 받은 클래스의 메서드를 사용을 할 수 있음

## Calendar
- calendar는 추상클래스라 인스턴스 생성을 하지 않음, 캘린더 사용 시 생성되는 인스턴스 : Gregorian Calendar

## Error와 Exception
### 에러 : 수습할 수 없는 심각한 오류
### 예외(Exception) : 예외처리를 통해 수습할 수 있는 덜 심각한 오류

## 예외처리
- 예외 : 프로그램 실행 중에 발생할 수 있는 예상치 못한 상황(예외)
- 프로그램의 정상적인 흐름을 유지하고 예외 상황을 안전하게 처리하는 프로그래밍 기법
```java
try
{
    // 예외가 발생할 것 같은 부분
}
catch (Exception e)
{
    // 예외 처리 로직을 가지는 블럭, 비워두는 건 좋지 않음
    // 예외가 발생했다는 것 정도는 알려야함
}
```