- 실습 진행 경로 : d\yang\likelion\backend_school_19\happyfront\my-react-app
- 컴포넌트는 react가 실행시킴

```javascript
import { useState } from "react";

const UseStateExam1 = () => {
  console.log("실행");

  const [count, setCount] = useState(0);
  console.log(count);
  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>카운트 : {count}</p>
      <button onClick={handleClick}>up</button>
    </div>
  );
};

export default UseStateExam1;
```
- 그냥 let count 변수 선언해서 count += 1; 하면 컴포넌트 재실행이 되지 않아서 화면에 반영 X
- useState, setCount 써야함
```
// ❌ 잘못된 방법
count = count + 1;

// ✅ 올바른 방법
setCount(count + 1);
```

# 렌더링
- React가 컴포넌트 함수를 호출하여 JSX를 얻는 과정

# 리스트 렌더링
- 리액트는 리스트 렌더링할때 키값을 요구함, 키값은 유일한 값이어야 함
```javascript
function FruitList() {
  const fruits = ['사과', '바나나', '오렌지', '포도', '딸기'];

  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```
- 키값으로 index를 사용
## key prop 사용 규칙
```
✅ 고유한 id 사용 (권장): key={item.id}
⚠️ index 사용 (제한적): 순서가 바뀌지 않을 때만
❌ 항목 추가/삭제/재정렬 시 index 사용 금지
```

```javascript
      {logs.map((log, index) => (
        <p key={index}>{log}</p>
      ))}
```
- => 뒤 오는 중괄호와 소괄호의 차이점
  - 중괄호 : return 따라와야함
  - 소괄호 : return 필요없음

## 버튼 클릭 로그 실습
```js
import { useState } from "react";

export default function CallbackExam() {
  const [logs, setLogs] = useState([]);

  const doClick = (title) => {
    console.log(`${title} 클릭됨 (${new Date().toLocaleTimeString()})`);
    setLogs([...logs, `${title} 클릭됨 (${new Date().toLocaleTimeString()})`]);
  };

  return (
    <div>
      <ActionButton title={"저장"} color="red" onAction={doClick} />
      <ActionButton title={"삭제"} color={"green"} onAction={doClick} />
      <ActionButton title={"지우기"} color={"blue"} onAction={doClick} />

      <div>
        <h2>로그 : </h2>
        {logs.map((log, index) => (
          <p key={index}>{log}</p>
        ))}
      </div>
    </div>
  );
}

function ActionButton({ title, color, onAction }) {
  return (
    <button
      style={{ backgroundColor: color, color: "white" }}
      onClick={() => onAction(title)}
    >
      {title}
    </button>
  );
}
```
### 동작 순서
- ActionButton 컴포넌트를 생성, 불필요한 반복을 줄임
```js
function ActionButton({ title, color, onAction }) {
  return (
    <button
      style={{ backgroundColor: color, color: "white" }}
      onClick={() => onAction(title)}
    >
      {title}
    </button>
  );
}

// return 구문 내 ActionButton 사용 예
<ActionButton title={"저장"} color={"red"} onAction={doClick} />
<ActionButton title={"삭제"} color={"green"} onAction={doClick} />
<ActionButton title={"지우기"} color={"blue"} onAction={doClick} />

```
- title, color, onAction을 props로 받아서 버튼의 배경색, 버튼에 표시될 문자, 이벤트핸들러를 설정

```js
  const [logs, setLogs] = useState([]);

  const doClick = (title) => {
    console.log(`${title} 클릭됨 (${new Date().toLocaleTimeString()})`);
    setLogs([...logs, `${title} 클릭됨 (${new Date().toLocaleTimeString()})`]);
  };
```
- const[logs, setLogs] = useState([]);
    - 수정할 값의 이름 logs, logs를 수정할 메소드 명 setLogs, 초기값은 []
- title 값을 받아와서 기존 데이터(...logs : 스프레드 연산자) 뒤에 새 데이터를 넣음
- ${} 사용위해 백틱(`) 사용
- 버튼 클릭 시 setLogs로 logs가 갱신되고 컴포넌트가 다시 그려짐

## 조건부 메시지가 있는 Counter
- 누르는 버튼에 따라 값이 증감하고 초기화 버튼을 누르면 값이 0으로 초기화됨
- 카운터에 출력되는 값에 따라 양수,음수,0인지 출력되는 메시지가 있음
```js
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div style={{ padding: '20px', textAlign: 'center' }}>
      <h2>카운터</h2>
      <p style={{ fontSize: '2em' }}>{count}</p>

      {count > 0 && <p style={{ color: 'blue' }}>양수입니다!</p>}
      {count < 0 && <p style={{ color: 'red' }}>음수입니다!</p>}
      {count === 0 && <p style={{ color: 'gray' }}>0입니다.</p>}

      <button onClick={() => setCount(count + 1)}>증가</button>
      <button onClick={() => setCount(count - 1)}>감소</button>
      <button onClick={() => setCount(0)}>초기화</button>
    </div>
  );
}
```
- && 으로 간단한 비교 + 바로 출력 코드도 완성할 수 있음
- onClick 이벤트에 화살표함수로 바로 넘겨줄수도 있음
- && 사용하지 않고 함수를 선언해서 조건에 따른 메시지를 설정, 출력할 수도 있음

## 컴포넌트 분리
- 데이터를 가지고 있는 컴포넌트와 화면을 그리는 컴포넌트를 분리
- 관심사 분리의 원칙을 따름
- 재사용성 증대, 코드의 복잡도 저하, 테스트 용이, 성능 최적화, 개발 편의성 및 가독성 증대등의 이점이 있다.

## TodoComponent 분리
- 원래 하나인 TodoComponent를 용도에 맞게 분리하는 과정 
- 초기 데이터 및 useState를 이용한 새로운 데이터 Input : TodoComponent
- 새 데이터 입력 화면 : TodoInput
- Todo 목록 출력 : TodoList
- Todo 개별 출력 : TodoItem