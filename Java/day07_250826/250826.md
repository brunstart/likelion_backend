## 다형성
- 껍데기는 하난데 구현은 여러 개

## 상속의 3가지 특징
1. 부모는 자식을 가리킬 수 있다.
2. 필드는 타입을 따른다.
3. 메소드는 오버라이드 되면 무조건 자식 것을 사용한다.

## 오버로딩 vs 오버라이딩

### 오버로딩
- 이름 같은 메소드에 매개변수를 다르게 하는것

### 오버라이딩
- 완전히 똑같이 다시 정의하는 것
- 상속관계에서만 가능


## 업캐스팅, 다운캐스팅
- 부모와 자식 클래스 간의 형변환, 클래스는 레퍼런스 타입이므로 참조형 캐스팅이라고도 함
- 상속관계일 때만 가능
- 자식 -> 부모의 경우 묵시적으로 가능 (업캐스팅)
- 부모 -> 자식의 경우 명시적으로 형변환을 해야함 (다운캐스팅)

## getter, setter
- 필드로의 직접적인 접근을 막고(접근제한자 private 이용)
- 메소드를 통해 접근하도록 하는 방법
- 주로 값을 얻을 때는 getter, 값을 설정할 때는 setter를 이용

## 추상 클래스 (abstract class)
- 비슷한 것들을 일반화시킬 목적으로 생성하는 클래스
- 인스턴스를 생성할 수 없는 클래스
- abstract 키워드 사용
- 장점 : 추상 메소드를 가질 수 있다. 클래스라서 일반 필드, 일반 메소드도 가질 수 있다.

### 추상 메소드 (abstract method)
- 이 클래스 상속받아 사용할 클래스 들에게 강제성을 부여하는 메소드
- 해당 기능을 일관성있게 구현하도록 제시하는 기능
- 표준, 강제성 부여 가능
- 추상 메소드로 선언된 것들은 자식으로 형변환 하지 않아도 사용가능
```java
//  추상 클래스
public abstract class Animal {
    
    // 추상 메소드
    public abstract void makeSound();       // 모든 동물이 소리내는 걸 여기서 구현불가
                                            // 소리낸다. 라는 개념만 넣어놓고 구현은 X -> abstract 키워드 사용
                                            // abstract 메소드는 abstract 클래스 안에서만 쓸 수 있음. 클래스도 abstract 키워드 사용
                                            // 추상클래스의 추상메소드는 반드시 구현해야 함. 안하면 오류남.
}
```

```java
    public static void main(String[] args) {
//        추상 클래스는 객체 생성이 불가능하다.
//        추상 클래스는 미완성된 설계도 -> 물건 제작 불가 = 인스턴스 생성 불가
//        Animal animal = new Animal();

//        타입으로의 역할은 모두 가능
        Animal animal = new Dog();
        Animal animal1 = new Cat();

//        부모타입으로 자식이 새로 구현한 메소드 사용불가
//        메소드는 오버라이드 되면 무조건 자식 것을 사용
//        추상 메소드로 선언한 경우는 형변환 없이 사용가능
        animal1.makeSound();
    }
```

- 부모타입으로 자식이 새로 구현한 메소드 사용불가
- 메소드는 오버라이드 되면 무조건 자식 것을 사용
- ### **추상 메소드로 선언한 경우는 타입이 추상 클래스(부모 클래스)여도 형변환 없이 사용가능**

- 메소드 선언 시 final 키워드 사용하면 오버라이딩이 금지됨.

## 인터페이스
- ### 기능의 통일화(핵심)
- implements 키워드로 인터페이스를 불러옴
- 인터페이스는 여러개 불러오는게 가능  
이유 : 상속의 경우에는 여러개를 불러오면 어떤걸 사용할지 알 수 없기 때문에 불가하지만 인터페이스는 메소드가 미구현 되어있음.  

- 오버라이딩 후 사용되는 건 인터페이스를 물려받은 클래스의 메소드라서 인터페이스 쪽 메소드가 겹쳐도 상관이 없음
- 인터페이스들끼리도 상속이 가능. 다중상속 가능

### 인터페이스도 타입으로 사용이 가능
```java
public interface Drawble
{
    void draw();    // 추상메소드(구현부가 없는 메소드)
    void erase();
}

public class PhotoTest implements Drawable
{
    // 추상클래스도 타입으로 사용가능
    // 인터페이스도 타입으로 사용이 가능하다.

    Drawable d = new Photo("a.png", 200,500);       // 타입을 인터페이스로 사용

    // d. 어떤 것 까지 사용이 가능? Drawble이 가진 것까지만 사용 가능
        d.draw();
        d.erase();

    // Drawable d 타입을 사용할 경우의 장점은?
    // 부모 타입을 이용하는 이유 : 부모 타입이 가진것만 사용할 수 있음 -> 타입이 제공하는 것만 접근 가능
    // 원하는 접근 범위 설정이 가능 (보안상의 이유도 되는듯)
}
```

- 기능을 인터페이스로 통일해서 사용자의 편의성을 높일 수 있음

## Java version 8에서 추가된 인터페이스 내 메소드
### 1. default 메소드
필요하면 자식클래스가 오버라이드해서 사용하라는 목적으로 만든 메소드
### 2. static 메소드
미리 메모리에 할당돼서 따로 Drawable을 implements하지 않아도 사용가능

```java
//    java version 7까지는 구현체를 가질 수 없었다.
//    version 8에서 추가된 메소드.
//    1. default 메소드 : 필요하면 자식클래스가 오버라이드해서 사용하라는 목적으로 만든 메소드
    default void defaTest()
    {
        System.out.println("필요하면 자식클래스가 오버라이드해서 사용하는 것이 목적");
    }

//    version 8에서 추가된 또 다른 메소드
//    2. static 메소드 : 미리 메모리에 할당돼서 따로 Drawable을 implements하지 않아도 사용가능
    static void showInfo()
    {
        System.out.println("STATIC TEST");
    }
```

## 캡슐화
- 객체 내부의 속성이나 행위를 외부에서 직접 접근할 수 없게 하는 것
- 목적 : 변경에 유연한 프로그램을 만드는 동시에 보안적인 프로그램을 만들기 위해

## final
- 상속을 금지시키려면 클래스에 final을 사용
- 예시) public final class 클래스명

### 싱글톤 패턴
- 특정 클래스의 객체를 오직 하나만 생성하고, 프로그램 전역에서 이 유일한 객체에 접근할 수 있도록 하는 디자인 패턴

### 팩토리 메소드 패턴
- 객체 생성을 공장(Factory) 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴

### Deprecated
- 더 이상 java에서 지원하지 않는 기능을 의미
- 해당 안내문구 뜨면 다른 기능 사용 권장

### 이름없는 클래스 (Anonymous Class)
- new 생성자(){...}
- 생성자 뒤에 중괄호가 나오고 코드를 오버라이딩하여 구현

## Object 
- 모든 객체들의 상위 클래스 
- 모든 클래스들의 레퍼런스 변수를 이용해서 사용될 수 있는  
우리가 구현한 적 없는 메소드들이 있음 -> Object가 가지고 있는 메소드

```java
Yang yang = new Yang();

// Yang 클래스에 아무것도 없어도 toString() 메소드를 불러올 수 가 있음
System.out.println(yang.toString());  
```