#### 주사위 추상화
- class 명 : Dice
  - 필드
    - int face // 면
    - int eye  // 눈
  - 기능 - 던지기, 굴리기
    - roll


## 메소드 오버로딩
- 같은 이름의 메소드를 **여러 개** 정의 하는것
- 매개변수의 **개수**나 **타입**이 달라야 함
- 반환타입만 다른 것은 오버로딩이 아니다.

## 생성자
- 생성자가 한 번도 정의된 적이 없다면 컴파일러가 자동으로 디폴트 생성자를 생성.
- 메소드와 흡사하나 리턴타입이 없고, 메소드 명이 클래스 명과 동일함.
- 생성자 오버로딩 또한 가능
- 선언 시 리턴타입이 없어야 함. 리턴 타입이 있으면 컴파일러가 메소드로 인식


## this
- 나 자신을 가리키는 키워드
- 클래스 내 변수와 생성자의 매개변수의 이름이 같을 경우 구분을 위해 사용

```java
public class Book {
    String title;
    String author;
    int price;

    public Book(String title)
    {
        this.title = title;
    }
    
} 
```
Book 생성자의 매개변수를 t 등으로 바꾸면 구분이 돼서 this를 사용할
필요는 없지만 코드의 주석화에는 맞지 않는 사용법.

```java
    public Book(String title, String author)
    {
        this.title = title;
        this.author = author;
    }
    
    public Book(String title, String author, int price)
    {
        this.title = title;
        this.author = author;
        this.price = price;
    }
```
생성자 오버로딩 시 중복되는 부분이 너무 많다
## this()
- 내 생성자 (같은 클래스의 다른 생성자를 호출)
- this()는 생성자의  **첫번째 줄** 에서만 가능

```java
    public Book(){
        this("java", "양승민", 3000);
    }

    public Book(String title)
    {
        this(title, "", 0);
        System.out.println("Book(t) 실행");
    }

    public Book(String title, String author, int price)
    {
        this.title = title;
        this.author = author;
        this.price = price;
        System.out.println("Book(t,a,p) 실행");
    }
```

## final
- 클래스 앞에 final을 붙이는건 상속을 허용하지 않겠다는 의미
- 예시) public final class Math
- final이 없으면 상속받아서 메소드 등을 마음대로 변경할 수 있게됨  
  그렇게 되면 사용자가 헷갈릴 수 있기 때문에 상속을 막아놓음

## 메소드 체이닝
- 메소드가 반환하는 객체가 메소드를 가지고 있을 경우 반환 객체의 메소드를  
바로 연달아 호출 가능
```java
    // Person 클래스 내에 있는 setAddress 메소드       
    // this를 반환하는 메소드 (메소드 체이닝)
    public Person setAddress(String address) {
        this.address = address;
        return this;  // 현재 객체를 반환
    }
    
    Person person = new Person("김철수", 25);

    // 메소드 체이닝
    person.setAddress("서울시 강남구").setAge(26);
```
Person 클래스에 setAddress 메소드가 있고 setAddress가 person을  
return 하기 때문에 Person 클래스의 setAge를 연달아 호출이 가능

## Import
- 다른 패키지의 클래스를 사용할 때 코드 상단에 import 필요.
- import 하지 않을 경우 클래스 사용 시 패키지 명까지 같이 기재 해야함.
- 서로 다른 패키지의 같은 이름인 클래스 둘을 사용하려고 하면 패키지명을 모두 명시해야한다.
```java
    java.util.Scanner scanner;
    examplePackage.util Scanner examScanner;
```
- 

## 패키지
- 관련된 클래스들을 그룹화하는 디렉토리 구조
- 클래스의 충돌을 방지하고 관리를 용이하게 함
- 도메인 역순으로 작성하는 것이 관례 (예 : com.company.project)
- CLI에서 패키지 내 클래스를 사용할 경우 패키지 명을 포함해서 적어야 동작

## 인스턴스 필드
-  객체(인스턴스)가 생성될 때 메모리에 올라감

## 클래스 필드
- 프로그램이 시작할 때 메모리에 올라감


##### new 연산자를 사용할 때 마다 메모리에 인스턴스 생성.
##### static한 필드는 클래스가 로딩될 때 한번 메모리에 올라가고 초기화된다.
##### 인스턴스 메소드는 인스턴스를 생성하고 나서 레퍼런스 변수를 이용해 사용할 수 있다.
##### 인스턴스 필드, 메소드는 반드시 객체가 인스턴스화 되어야 쓸 수 있다.
