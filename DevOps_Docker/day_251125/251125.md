# Docker
- 지워도 시스템에 미치는 영향이 적다

# Dockerfile
- 도커 이미지를 만드는 스크립트
- Dockerfile은 반드시 FROM으로 시작 (일부 예외 있음)

## 주요 지시자
### FROM
- 베이스 이미지

### RUN
- 컨테이너 환경에서 셸 명령어 실행
- 새 레이어 생성
- 패키지 설치, 파일 편집 등 수행

```
# 패키지 설치
RUN apt-get update && apt-get install -y python3

# 여러 명령어 연결 (레이어 최소화) ⭐⭐
RUN apt-get update && \
    apt-get install -y \
        python3 \
        python3-pip \
        git && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# pip 패키지 설치
RUN pip install --no-cache-dir flask gunicorn
```

### COPY / ADD - 파일 복사
의미:
- 로컬(빌드 컨텍스트) 파일을 이미지 내부로 복사
- COPY: 순수 파일 복사 (권장)
- ADD: 추가 기능(압축 해제, URL 다운로드) 있으나 일반적으로 COPY 권장

### WORKDIR - 작업 디렉토리
역할:
- 이후 명령어의 작업 디렉토리 설정
- RUN, CMD, ENTRYPOINT, COPY, ADD의 기본 경로

### EXPOSE - 포트 명시
개념:
- 컨테이너가 사용할 포트를 문서화
- 실제 외부 접근은 -p 포트 매핑 필요
- 주로 문서적 의미

### ENV - 환경 변수
역할:
- 컨테이너 내부 환경 변수 설정
- 빌드 시 및 런타임에 사용 가능

### CMD - 기본 실행 명령
역할:
- 컨테이너 시작 시 기본으로 실행할 명령
- docker run 시 명령어로 덮어쓰기 가능
- Dockerfile에 하나만 존재 (여러 개 시 마지막만 유효)

### ENTRYPOINT - 실행 엔트리포인트
역할:
- 컨테이너 실행 시 반드시 실행할 명령
- CMD는 ENTRYPOINT에 전달될 인자로 사용 가능
- docker run 명령어로 덮어쓰기 어려움 (--entrypoint 필요)

## 빌드 순서 최적화
- 변경 빈도가 낮은 것부터

## 도커파일을 이용해 프로젝트를 도커 이미지로 생성
1. .\gradlew build -x test : 테스트 제외 빌드
  

2. Dockerfile 생성
```
FROM eclipse-temurin:21-jdk-alpine

WORKDIR /app

COPY build/libs/*-SNAPSHOT.jar dockerapp.jar

ENTRYPOINT ["java", "-jar", "dockerapp.jar"]
```
3. docker build -t [이미지명:버전] .
   - 도커에서 이미지 빌드


4. docker run -d -p [포트넘버:포트넘버] --name [별칭] [이미지명:버전]
   - 컨테이너 생성


5. docker login (도커 허브에 로그인이 선행되어야 함)


6. 이미지에 도커 허브 형식 태그 추가
    - docker tag [이미지명:버전] [도커허브ID/이미지명:버전]
    - docker tag [이미지명:버전] [도커허브ID/이미지명:latest]


7. docker push 명령어를 이용해서 내 이미지를 올릴 수 있음
   - docker push mydockerid/myapp:1.0
   - docker push mydockerid/myapp:latest

8. docker pull [이미지명]
- 허브에 올라온 이미지를 받아올 수 있음 
- 그 전에 docker login 먼저 해야 함

9. 사용 후 docker logout


# Docker Compose
- 여러 개의 Docker 컨테이너를 하나의 설정 파일로 관리하는 도구
- 명령어가 너무 길고 복잡함, 매번 타이핑 해야 함, 팀원들과 공유 어려움, 실수하기 쉬움

### docker-compose의 기본 구조
- docker-compose.yml 파일 구조
```
services:          # 실행할 컨테이너들
  service1:        # 서비스 이름
    # 서비스 설정
  service2:
    # 서비스 설정

networks:          # 네트워크 설정 (선택)
  network1:

volumes:           # 볼륨 설정 (선택)
  volume1:
```

## 서비스 정의 (services)
### image: 사용할 Docker 이미지
```
services:
  db:
    image: mysql:8.0      # Docker Hub의 이미지
```
### container_name: 컨테이너 이름
```
services:
  db:
    image: mysql:8.0
    container_name: my-mysql   # 지정하지 않으면 자동 생성
```
### ports: 포트 매핑
```
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"          # 호스트:컨테이너
      - "8443:443"
```
### environment: 환경 변수
```
services:
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret123
      MYSQL_DATABASE: myapp
```
또는:
```
services:
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret123
      - MYSQL_DATABASE=myapp
```
## 빌드 설정 (build)
### 이미지 대신 Dockerfile로 빌드:
```
services:
  app:
    build: .                    # 현재 디렉토리의 Dockerfile 사용
    ports:
      - "8080:8080"
```
### Dockerfile 위치 지정:
```
services:
  app:
    build:
      context: ./backend        # Dockerfile이 있는 디렉토리
      dockerfile: Dockerfile    # Dockerfile 이름
    ports:
      - "8080:8080"
```

## 볼륨 (volumes)
### Named Volume: 데이터 영속성
```
services:
  db:
    image: postgres:15
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:    # 볼륨 선언
```
### Bind Mount: 로컬 파일 마운트
```
services:
  web:
    image: nginx:alpine
    volumes:
      - ./html:/usr/share/nginx/html    # 로컬:컨테이너
      - ./nginx.conf:/etc/nginx/nginx.conf
```

## 네트워크 (networks)
### 기본 동작: - Docker Compose는 자동으로 전용 네트워크를 생성 - 같은 Compose 파일의 서비스들은 서비스 이름으로 통신 가능
```
services:
  backend:
    image: myapp:1.0

  db:
    image: postgres:15
```
### `backend` 컨테이너에서 `db`라는 이름으로 데이터베이스에 접근 가능:
```
// Spring Boot application.properties
spring.datasource.url=jdbc:postgresql://db:5432/myapp
```

### 커스텀 네트워크:
```
services:
  web:
    image: nginx:alpine
    networks:
      - frontend

  app:
    image: myapp:1.0
    networks:
      - frontend
      - backend

  db:
    image: postgres:15
    networks:
      - backend

networks:
  frontend:
  backend:
```
## 서비스 의존성 (depends_on)
### 시작 순서 제어:
```
services:
  app:
    image: myapp:1.0
    depends_on:
      - db          # db가 시작된 후 app 시작

  db:
    image: mysql:8.0
```


## 기본 명령어
```
# 서비스 시작 (백그라운드)
docker-compose up -d

# 서비스 시작 (포그라운드, 로그 실시간 확인)
docker-compose up

# 서비스 중지 및 삭제
docker-compose down

# 서비스 중지 및 삭제 (볼륨도 삭제)
docker-compose down -v

# 실행 중인 서비스 확인
docker-compose ps

# 로그 확인
docker-compose logs

# 특정 서비스 로그 확인
docker-compose logs app

# 로그 실시간 확인
docker-compose logs -f
```

## 서비스 제어
```
# 특정 서비스만 시작
docker-compose up -d db

# 서비스 재시작
docker-compose restart app

# 서비스 중지 (삭제하지 않음)
docker-compose stop

# 서비스 시작 (이미 생성된 컨테이너)
docker-compose start

# 실행 중인 컨테이너에 명령 실행
docker-compose exec app bash
docker-compose exec db mysql -u root -p
```

## 빌드 관련
```
# 이미지 빌드
docker-compose build

# 빌드 후 시작
docker-compose up -d --build

# 특정 서비스만 빌드
docker-compose build app
```