# 웹 서버 vs 웹 어플리케이션 서버(WAS)
- 웹 서버 : 정적처리
- WAS : 동적처리

# NginX
- 웹 서버의 일종

## 주요 용도
1. 정적 파일 서비스
- HTML, CSS, JavaScript, 이미지 등 정적 자원 제공
- 빠른 파일 I/O 처리
2. Reverse Proxy
- 클라이언트 요청을 백엔드 서버로 중계
- 백엔드 서버 IP/포트 은닉
- 보안 계층 추가
3. 로드 밸런싱
- 여러 서버로 트래픽 분산
- 서버 부하 균등화
- 장애 시 자동 우회 (Failover)
4. SSL/TLS 종단 (SSL Termination)
- HTTPS 암호화/복호화 처리
- 백엔드 서버 부담 감소
- 인증서 중앙 관리
5. 캐싱
- 정적/동적 콘텐츠 캐싱
- 백엔드 서버 요청 감소
- 응답 속도 향상

## Reverse Proxy vs Forward Proxy
### Forward Proxy (일반 프록시):
```
Client → Forward Proxy → Internet → Server
        (클라이언트 대리)
```
- 클라이언트를 대신하여 요청 수행
- 클라이언트 IP 숨김
- 예: 회사 방화벽, VPN
### Reverse Proxy:
```
Client → Internet → Reverse Proxy → Backend Server
                      (서버 대리)
```
- 서버를 대신하여 요청 처리
- 서버 IP 숨김
- 로드 밸런싱, 캐싱, SSL 종단

# 로드 밸런싱
- 로드 밸런싱(Load Balancing)은 들어오는 네트워크 트래픽을 여러 서버로 분산하여 부하를 균등하게 나누는 기술.
## 로드 밸런싱 알고리즘
1. Round Robin (라운드 로빈)
- 요청을 순차적으로 각 서버에 분배
- 가장 간단하고 공평한 방식
- 서버 성능이 동일할 때 적합
```
Request 1 → Server 1
Request 2 → Server 2
Request 3 → Server 3
Request 4 → Server 1 (반복)
```

2. Weighted Round Robin (가중치 라운드 로빈)
- 서버마다 가중치를 부여
- 성능이 좋은 서버에 더 많은 요청 할당
```
upstream backend {
    server api1:8080 weight=3;  # 3배 더 많은 요청
    server api2:8080 weight=1;
    server api3:8080 weight=1;
}
```

3. Least Connections (최소 연결)
- 현재 연결이 가장 적은 서버로 요청 전달
- 세션이 긴 애플리케이션에 적합
```
upstream backend {
    least_conn;
    server api1:8080;
    server api2:8080;
    server api3:8080;
}
```

4. IP Hash
- 클라이언트 IP를 해싱하여 항상 같은 서버로 전달
- 세션 유지 (Sticky Session) 필요 시 사용
```
upstream backend {
    ip_hash;
    server api1:8080;
    server api2:8080;
    server api3:8080;
}
```

5. Least Time (상용 버전)
- 응답 시간과 활성 연결 수를 고려
- Nginx Plus (유료 버전)에서 지원


## Health Check (헬스 체크)
Nginx는 백엔드 서버의 상태를 주기적으로 확인하여 장애가 발생한 서버로는 요청을 보내지 않음.

### Passive Health Check (수동 헬스 체크):
- 실제 클라이언트 요청으로 서버 상태 판단
- 요청 실패 시 해당 서버를 일시적으로 제외
```
upstream backend {
    server api1:8080 max_fails=3 fail_timeout=30s;
    server api2:8080 max_fails=3 fail_timeout=30s;
    server api3:8080 max_fails=3 fail_timeout=30s;
}
```
- max_fails: 최대 실패 횟수 (기본값: 1)
- fail_timeout: 실패 후 재시도까지 대기 시간

# Dockerfile
- Dockerfile로 이미지 생성
```
## 1. Base Image: JDK 21 사용 (가볍고 안정적인 eclipse-temurin 사용 권장)
#
#FROM eclipse-temurin:21-jdk-alpine
#
## 2. 작업 디렉토리 설정
#
#WORKDIR /app
#
## 3. 빌드된 JAR 파일을 Docker 이미지 내부로 복사
#
## 일반적으로 build/libs 경로에 생성됩니다. plain jar가 아닌 실행 가능한 jar를 복사해야 합니다.
#
#COPY build/libs/*-SNAPSHOT.jar app.jar
#
#
#
## 4. 컨테이너 실행 시 실행할 명령어
#
#ENTRYPOINT ["java", "-jar", "app.jar"]
```
## 멀티 스테이지 
```
# 멀티 스테이지에서는 빌드까지 같이 함
# 빌드 스테이지 (교안은 . . 으로 전체 복사인데 이 Dockerfile은 필요한것만 복사하는걸로 작성)

FROM gradle:8.11-jdk21 AS build
WORKDIR /app

COPY gradlew .                          # COPY 구문이 실행된 위치의 gradlew를 WORKDIR인 /app으로 복사
COPY gradle gradle                      # COPY 구문이 실행된 위치의 gradle을 WORKDIR인 /app으로 디렉토리 째로 복사
COPY build.gradle settings.gradle ./    # COPY 구문이 실행된 위치의 build.gradle, settings.gradle 파일을 WORKDIR인 /app으로 복사

RUN chmod +x ./gradlew                  # chmod +x 권한이 없을 수도 있어서 설정해 주는것

COPY src src

RUN ./gradlew clean build -x test --no-daemon
# 테스트 안하고 데몬없이 빌드하겠다.


# 두번째 스테이지
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app

COPY --from=build /app/build/libs/*-SNAPSHOT.jar app.jar

ENTRYPOINT ["java", "-jar", "app.jar"]
# 이름이 build인 스테이지에서 생성한 결과물에서만 복사
```

# Nginx 설정 및 실행
## Nginx 설정 파일 작성

```
worker_processes  1;

events {
    worker_connections  1024;    # 동시에 연결할 수 있는 최대 수 = processes * connections = 1024
}

# HTTP에 대한 설정
http {
    # 로드 밸런싱 대상
    upstream spring-backend {           # 가상 그룹 선언
    
        ip_hash;                        # IP Hash 방식을 사용할 경우 추가
                                        # 같은 클라이언트 IP는 항상 같은 서버로 연결
                                        # 세션 데이터가 서버에 저장되어 있을 때 유용
    
        # Round Robin 방식 (기본값)
        server api1:8080;               # 컨테이너 이름을 사용해야함
        server api2:8080;
        server api3:8080;
        
        # 가중치 Round Robin 방식 - 각 서버별로 가중치를 둬서 빈도 조절이 가능
        server api1:8080 weight=3;
        server api2:8080 weight=1;
        server api3:8080 weight=1;
        
        # 헬스 체크 - max_fails 횟수만큼 실패 시 서버를 일시 제외, fail_timeout만큼 기다렸다가 재시도
        # api1 stop 해놓고 8088로 접속 시도 시 api1로 3번 접속 시도 시 제외, 30초 후에 재시도
        server api1:8080 max_fails=3 fail_timeout=30s;
        server api2:8080 max_fails=3 fail_timeout=30s;
        server api3:8080 max_fails=3 fail_timeout=30s;
    }

    server {
        listen 80;                      # 80번 포트로 들어왔을 때

        location /nginx_status {        # nginx_status 라는 url로 들어오는 경우
            stub_status on;
            access_log off;
            allow 127.0.0.1;
            allow 172.0.0.0/8;  # Docker 네트워크
            deny all;
        }

        location / {                    # / -> 모든 주소를 의미, /api/일 경우면 주소가 /api/아래 모든 주소에 대한 처리를 설정
            proxy_pass http://spring-backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

# Docker Compose로 통합관리
## docker-compose.yml 작성
```
services:
  api1:
    image: my-spring-app:1.0
    container_name: api1
    hostname: api1
    environment:
      - SERVER_PORT=8080
    ports:
      - "8081:8080"
    networks:
      - spring-net

  api2:
    image: my-spring-app:1.0
    container_name: api2
    hostname: api2
    environment:
      - SERVER_PORT=8080
    ports:
      - "8082:8080"
    networks:
      - spring-net

  api3:
    image: my-spring-app:1.0
    container_name: api3
    hostname: api3
    environment:
      - SERVER_PORT=8080
    ports:
      - "8083:8080"
    networks:
      - spring-net

  nginx1:
    image: mynginx:1.0
    container_name: nginx1
    ports:
      - "8088:80"
    networks:
      - spring-net
    depends_on:
      - api1
      - api2
      - api3

networks:
  spring-net:
    driver: bridge
```
- 이렇게 docker-compose.yml에 한번에 작성해놓으면 이미지만 미리 만들어놓고
```
# 한번에 컨테이너 생성이 가능
docker compose up -d
```

```
# 올린것들 전부 stop하고 삭제까지 가능
docker compose down
``` 

# SSL/TLS 설정
- 보안 때문에 함

# Rate Limiting (요청 제한)
- http 구문 내에 
```
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;
```
- 를 추가해서 요청 제한을 할 수 있음 -> 이상 현상 탐지 및 공격 방지 등등


# AWS EC2
## 인스턴스 시작 방법
1. EC2 인스턴스 서비스 선택 -> 인스턴스 시작 버튼 클릭
2. 인스턴스 설정
   - 이름은 원하는대로
   - AMI : 실습은 무료티어 가능한 정도로도 충분
3. 인스턴스 유형 선택 (무료티어 되는 정도)
4. 키 페어 생성
   - 유형 : RSA
   - 프라이빗 키 파일 형식 : pem, ppk (실습은 pem으로 진행)
5. 보안설정
   - VPC : 기본 VPC 사용
   - 서브넷 : 자동 할당
   - public IP 자동 할당 활성화
6. 스토리지 구성
   - 무료 티어에서 30GB까지 가능해서 30GB로 함

## SSH를 통한 서버 접속
- Windows 사용자 (Powershell)
```
# SSH 접속
ssh -i C:\Users\YourName\Downloads\spring-boot-key.pem ec2-user@<EC2_PUBLIC_IP>

# permission denied 됐을 경우
# 1. 상속된 권한 제거 (기존 권한 초기화)
icacls.exe "lion-key.pem" /reset

# 2. 현재 사용자에게만 '읽기(Read)' 권한 부여
icacls.exe "lion-key.pem" /grant:r "$($env:USERNAME):R"

# 3. 상속 권한 차단 (다른 사용자 접근 불가)
icacls.exe "lion-key.pem" /inheritance:r
```