- 외부에서 들어온 데이터는 다 문자열로 들어옴

### DataInputStream()
- 매개변수로 다른 InputStream을 받음 = 장식 = 기능이 중요

### 주인공
- 어떤 대상에게서 읽어들일지, 쓸지를 결정

## 표준 입출력
### System.in
- 키보드로부터 입력 받음
### System.out
- 콘솔에 일반 메시지 출력

### try-with-resource
- 입출력에 사용되는 객체는 문제를 방지하기 위해 finally에 close()를 넣어서 닫아야했다.
- try-with-resource를 사용하면 알아서 해제해준다.
```java
        try (FileReader reader = new FileReader("input.txt");
             FileWriter writer = new FileWriter("output.txt")) {
            //     try 블럭 구현부
            }
        } catch (IOException e) {
            //     catch 블럭 구현부
        }
```

### PrintWriter
```java
PrintWriter writer = new PrintWriter(new FileWriter("output.txt"));
```
- FileWriter를 PrintWriter로 감싸서 PrintWriter의 메서드 사용가능
  - System.out.println() : System.out(콘솔)에 출력
  - writer.println() : PrintWriter로 연 파일에 출력 (파일에 내용을 씀)


## 파일 입출력
- 데이터의 영속성을 보장하는 기능
- 디렉토리(폴더) 역시 파일로 취급, File 인스턴스 != 실제 파일
```java
File file1 = new File("파일 경로/파일명");
```
### File 메소드
- delete() : 파일을 삭제하고 성공 여부를 boolean으로 반환
- length() : 파일의 길이 반환
- canRead() : 파일 읽기가 가능한지
- canWrite() : 파일 쓰기가 가능한지
- getAbsolutePath() : 파일의 절대경로 반환
- 이외에도 많은 메소드가 있음

### 파일 입출력 과정
- 읽기
  * 연결 생성 (FileInputStream / FileReader)
  * 읽기 (read())
  * 리소스 해제 (close())
- 쓰기
  * 연결 생성 (FileOutputStream / FileWriter)
  * 쓰기 (write())
  * 리소스 해제 (close())
  * 운영체제마다 버퍼에 담아서 모이면 처리하는 방식을 사용
  * 리소스 해제를 해야 운영체제도 스케줄에 맞게 처리를 하기 때문에 닫아주는게 필요하다.

```java
bos.write(buffer, 0, bytesRead);
// buffer에 담겨있는걸 0부터 bytesRead까지 써라
```

### readLine()
- 바이트로 파일을 읽을 경우 -1이 파일의 마지막
- readLine()의 경우 String으로 반환을 하기 때문에 EOF의 조건이 -1이 아니라 NULL이다.

## 직렬화
- 객체를 바이트 스트림으로 변환하는 과정
- 직렬화 가능 대상 (Serializable 인터페이스를 구현하고 있는 객체)