## Spring framework
- 전부 Tomcat이라는 WAS(Web Application Server) 위에서 돌아감
- 스프링이 웹서버를 돌리는게 아님, 톰캣이 내장되어 있는 것

## WAS (Web Application Server)
- 요청과 응답을 받아서 처리할 수 있는건 WAS 밖에 없음
- 요청이 들어올 때는 요청을 추상화한 객체 Request에 넣음
  - 사용자의 브라우저가 뭔지, 어떤 언어를 쓰는지 같은 클라이언트의 정보를 요청에 담아서 보냄
  - 요청이 들어올 때 WAS가 만들었다가 응답을 보낼 때 소멸됨
- 응답을 추상화한 객체 Response가 만들어짐

## @ModelAttribute
- 스프링부트가 Request에 있는 값을 알아서 가져오고 Response에 값을 담아주고 함 (Handler Adapter가 역할 수행)

## 스코프
- 변수가 동작하는 범위
- 페이지 : 페이지가 살아있는 동안 살아있음
- 리퀘스트 : 요청이 들어와서 응답이 나갈 때 까지 살아있음, 요청마다 생김
- 세션 : 요청이 사라져도 살아있음, 사용자마다 생김
- 어플리케이션 : static한 범위

## 모델
- 리퀘스트나 세션에 직접 접근하는게 아니라 모델이 대신 접근함
- 값을 맡겨야 할 일이 있을 때 모델을 이용하면 스프링이 내부적으로 스코프에 알아서 넣음

## @Valid
- 값의 유효성 체크를 하는 어노테이션 
- 서버단에서 동작, build.gradle의 dependencies에 implementation 추가필요
- 자동으로 된다 --> 지켜야하는 규칙이 있다
- BindingResult에 검사결과를 넣음

## 상태관리
- Http 프로토콜은 상태를 유지하지 않음, 응답하고 연결을 종료함
- 서블릿은 스레드로 동작
    - 요청이 올때마다 스레드가 추가됨
    - 해당 클라이언트가 요청을 보내고 응답을 보내면 연결을 끊음
    - 다시 요청을 하면 서버는 다시 요청을 했는지 처음인지 알 방법이 없음
    - 클라이언트를 식별할 필요가 있음
      <br><br>
### 쿠키나 세션이 사용자가 보낸 정보가 아니라 어플리케이션이 원하는 값들로 구성됨

### 쿠키 : 유지해야하는 정보를 클라이언트가 갖고 있음
- 클라이언트한테 줬는데 탈취당하는 경우가 있음
- 브라우저한테 보내줘야해서 문자열로 보낼 수 밖에 없음 (브라우저는 자바 객체를 받을 수 없다)
- setPath() : 쿠키를 사용할 수 있는 URL 경로를 설정
  - 별도로 지정하지 않으면 기본경로로 설정됨
  - 최상위 경로 ("/") 로 설정할 경우 해당 도메인의 모든 경로에서 쿠키를 사용할 수 있음
- **이름이 중복되지 않음 (똑같은 이름의 쿠키를 또 저장하면 값이 갱신됨)**
- Cookie 객체를 생성해서 값을 가져올 수 있음
- @CookieValue 어노테이션 사용 시 원하는 이름의 쿠키를 편하게 가져올 수 있음
  <br><br>

### 세션 : 정보를 서버가 가지고 있는 기술
- 세션을 사용해도 내부적으로는 쿠키가 같이 사용됨 ( 세션을 만들어도 요청이 들어오면 누구 세션인지 구분이 필요해서 세션ID를 쿠키로 만들어서 보내놓음 ) <br><br>

- getSession() : 리퀘스트 객체에서 쿠키 정보를 가져옴, 세션ID 쿠키랑 비교, 있으면 세션 객체 반환
- 없으면 세션 객체 생성, 세션 ID 발급, 쿠키를 구워서 Response에 담아 브라우저에게 전달
- HttpSession으로 직접 접근해서 세션 생성, 삭제
- @SessionAttribute으로 직접 접근없이 세션을 다룸
- @SessionAttributes()를 클래스 위에 선언 시 파라미터로 넘겨주는 변수는 세션 스코프로 저장됨


## 예외처리
- @ControllerAdvice 사용
