## 추상화
- 공통적인 것들만 빼서 일반화

## 캡슐화
- 연관있는 것들만 묶어서 빼내는 것

## 상속
- 부모가 가진것을 모두 내 것처럼 사용할 수 있는것
- 복잡한걸 구현할 때 자바에 이미 구현되어 있는 내용을 상속받아서 나머지만 구현하는 방법으로  
활용 가능

## 오버라이딩
- 부모가 갖고 있는 기능을 그냥 쓰지 않고 자식 본인에게 알맞게 다시 정의해서 사용하는 것

## 추상클래스⭐⭐
- 자체적으로 인스턴스 생성 불가
- 추상메소드를 가질 수 있다

### 추상메소드
- abstract 키워드를 통해 추상메소드임을 밝혀야 구현부가 없어도 오류나지 않음
- 자식에게 강제성 부여 가능 (해당 메소드는 반드시 오버라이드 해야함)

## 인터페이스⭐⭐⭐
- 상속은 is-a, kind-of 관계여야 하는데 어떤 객체들끼리는 해당 관계가 성립하지 않음
- 상속으로 묶기는 좀 그런데 기능들을 통일하고 싶은 수요가 있음  


- 예) 비행기, 나비, 새는 모두 `날다`라는 기능을 갖고 있지만 상속하기에는 다른 점이 많다
- 이럴 때 사용하는 것이 인터페이스 : 기능을 통일화 하는 것  

### 왜 인터페이스를 통일하는게 좋을까???
- 비슷한 기능들을 한번에 묶어서 구현하도록 만들면 다른 객체들을 사용할 때 사용방법을  
통일함으로써 사용자들에게 편의성을 제공할 수 있다.


- 인터페이스는 빈 껍데기만 있다
```java
public interface AInter{
    void aMethod();
    void bMethod();
}
```
- 인터페이스는 상속이 가능, 다중상속도 가능

## final
- 변수에 사용 : 값 변경 불가
- 메서드에 사용 : 오버라이딩 불가
- 클래스에 사용 : 상속 불가

## Enum
- 열거형 타입을 선언해 줌으로써 잘못된 값이 들어가지 않게 함
- 자신이 쓰고싶은 값을 정의해서 사용
- 타입 안전성: 컴파일 시점에 타입 체크
- 상수 그룹화: 관련 상수들을 하나로 관리
- 싱글톤 보장: 각 열거 상수는 JVM 내에서 하나만 존재
- switch문 지원: 가독성 좋은 코드 작성 가능

```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

public class EnumTest {
    public static void main(String[] args) {
        Day today = Day.TUESDAY;
        today = "kang";     // 열거형 타입에 맞지 않는 값이라 오류가 발생
    }
}
```

## 내부 클래스
- 클래스 안에 클래스가 들어갈 수 있는가? 가능하다
- 우리는 여태 클래스 구현 시 String 등의 클래스들을 사용해왔다.
- 또한 클래스 내부에 필드처럼 클래스를 구현할 수도 있다.  
클래스 내에 구현이 되어있을 뿐 특별한 동작은 없다.

#### 1. 멤버 내부 클래스 (non-static) : 외부 클래스 멤버로 접근
#### 2. 정적 중첩 클래스 (static nested class) : static 필드만 접근 가능
#### 3. 지역 내부 클래스 (local inner class) : 메소드 내에 구현되는 내부 클래스
#### 4. 익명 내부 클래스 (anonymous inner class) : 내부에 구현된 익명 클래스

## Object 클래스
- 모든 클래스의 최상위 부모 클래스
- 모든 객체가 공통으로 가져야 할 기본 메소드 제공
- 다형성의 기반
```java
public class MyClass {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        MyClass.toString();
    }
}
```
- MyClass는 아무것도 정의하지 않았지만 Object 클래스가 가진 모든것을 사용 가능
### toString()
- 객체의 문자열 표현을 반환


### equals()
- Object가 가지고 있는 메소드, @Override해서 많이 사용
- equals()가 true면 hashCode()도 같아야 한다
- 하지만 hashCode()가 같다고 equals()가 true인 것은 아니다
```java
    @Override
    public boolean equals(Object o)
    {
        if (o == null || getClass() != o.getClass()) return false;
        MyClass myClass = (MyClass) o;      // 필드는 타입을 따르기 때문에 Object 타입으로는 name에 접근을 못하기 때문에 MyClass로 형변환함
        return Objects.equals(name, myClass.name);
    }
```
- 필드는 타입을 따른다 ⭐⭐⭐
- Object 타입으로는 name에 접근을 못하기 때문에 MyClass로 형변환함

### clone
- 객체의 복사본 생성

## String 클래스
- 클래스 생성 시 String을 이름으로 하면 java의 String이 아니라 내 패키지의 String을 참조해서  
사용하는 모든 String에 오류가 생길 수 있음
- String은 불변(Immutable) 객체. 한 번 생성된 문자열은 변경할 수 없다.
```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2);      // true (String Pool)
System.out.println(str1 == str3);      // false (다른 객체)
System.out.println(str1.equals(str3)); // true (내용 비교)

// 문자열 수정 시 새 객체 생성
String str4 = str1.concat(" World");
System.out.println(str1); // "Hello" (변경되지 않음)
System.out.println(str4); // "Hello World"
```
### String에서 쓰는 메소드
```java
String strr = "  Hello Java World  ";
// 길이와 문자 접근
System.out.println("length : " + strr.length());    // 20
System.out.println("5th : " + strr.charAt(5));      // 'l'

// 부분 문자열
System.out.println(strr.substring(8, 12));          // Java

// 검색
System.out.println(strr.indexOf("Java"));           // 8
System.out.println(strr.contains("Java"));          // true
System.out.println(strr.startsWith("   Hello"));    // true
System.out.println(strr.endsWith("World   "));      // true

// 변환
System.out.println(strr.toLowerCase());             //   hello java world  
System.out.println(strr.toUpperCase());             //   HELLO JAVA WORLD
System.out.println(strr.trim());                    //Hello Java World
System.out.println(strr.replace("Java", "C"));      //   Hello C World

// 분할과 겷합
String[] words = strr.trim().split(" ");            
System.out.println(Arrays.toString(words));         // [Hello, Java, World]

String joined = String.join("-", words);            
System.out.println(joined);                         // Hello-Java-World

// 형식화
String formatted = String.format("name : %s, age : %d", "양승민", 30); // name : 양승민, age : 30
System.out.println(formatted);
```

## StringBuilder, StringBuffer
|   구분    | StringBuilder | StringBuffer |
|:-------:|:-------------:|:----------:|
|   동기화   |  지원하지 않음  |    지원함     |
|   성능    |      빠름      |     느림     |
| 스레드 안정성 | 안전하지 않음 |    안전함     |
|  사용 환경  |  단일 스레드   |   멀티 스레드   |
### 동기화
- 여러 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 데이터 불일치 문제(Race Condition)를 방지하기 위해  
주어진 순간에 단 하나의 스레드만 특정 코드 영역(임계 영역)에 접근하도록 제한하는 메커니즘

### 상황에 따라 다르게 사용하는 클래스
- String : 문자열 변경이 거의 없는 경우
- StringBuilder : 단일 스레드에서 문자열 변경이 빈번한 경우
- StringBuffer : 멀티 스레드에서 문자열 변경이 빈번한 경우

## Math 클래스 
- Math 클래스는 모든 메서드가 `static`이므로 객체 생성 없이 사용
- abs(a) : a의 절대값 반환
- max(a, b) : a, b 중 최대값 반환
- min(a, b) : a, b 중 최소값 반환
- pow(a, b) : a의 b제곱 반환
- sqrt(a) : a의 제곱근 반환
- cbrt(a) : a의 세제곱근 반환
- 이외에도 많은 메서드들을 지원한다  
참고 : https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html