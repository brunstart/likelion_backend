## ThreadLocal
- ThreadLocal 클래스는 각 쓰레드가 고유한 값을 가질 수 있도록 함
- 쓰레드가 해당 변수를 읽거나 쓸 때, ThreadLocal은 그 쓰레드만을 위한 고유한 인스턴스를 반환
```java
    // ThreadLocal에게 값을 맡기기 위한 메소드
    public static void setUser(User user)
    {
        userThreadLocal.set(user);
    }

    // ThreadLocal에서 값을 얻어오기 위한 메소드
    public static User getUser() {
        return userThreadLocal.get();
    }

    // ThreadLocal을 초기화 하는 메소드
    public static void clear() {
        userThreadLocal.remove();   // 삭제해주는것 아주 중요
    }
```
### ThreadLocal 사용 후 삭제를 해주는게 중요하다
- 쓰레드 풀을 사용하고 있기 때문
- 쓰레드를 사용하면 소멸되지 않고 재사용 되기 때문에 값이 유지됨
- 재사용을 위해 값을 지워줄 필요가 있음

## Filter
- URL로 연결되기 전 사전작업을 하는 문지기같은 역할 
- 필터에서 복잡한 작업을 수행해서 얻는 값을 쓰레드 내에서 모두 사용하고 싶을 때 -> 쓰레드로컬을 사용한다.

## Security
- Security의 기본 동작
```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig {
        @Bean
        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
            // 1. 사용자가 아무것도 안했을 때 스프링부트의 시큐리티는 아래와 같은 설정으로 동작 (기본임)
            return http
                    .authorizeHttpRequests(auth -> auth
                            .anyRequest()   // 모든 요청에 대해
                            .authenticated()    // 인증을 요구
                    )
                    .formLogin(Customizer.withDefaults())
                    .httpBasic(Customizer.withDefaults())
                    .csrf(Customizer.withDefaults())
                    .build();
        }
    }
```
```java
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig {
        @Bean
        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
            return http
                    .authorizeHttpRequests(auth -> auth
                            .requestMatchers("/hi", "hello", "/test/*", "/loginForm", "/fail").permitAll()  // 특정 url만 로그인 후 볼수있게 설정 가능
                            .anyRequest().authenticated()
                    )
                    .formLogin(formLogin -> formLogin
                            // .loginPage("/loginForm")    // 시큐리티가 제공하는 로그인폼 페이지가 아닌 사용자가 원하는 페이지로 사용하도록 설정
                            .defaultSuccessUrl("/success", true)   // 로그인에 성공하면 어디로 갈지 결정, 두번째 파라미터 없거나 false면 /login 에서 로그인 했을때만 success로 감
                            // info, home을 요청하고 로그인하면 요청한 화면으로 감, 두번째 파라미터가 true면 로그인 성공했을때 무조건 success로 감
                            .loginProcessingUrl("/login_proc")  //
                            .usernameParameter("email") // 유저네임의 name을 변경할 수 있음
                            .passwordParameter("pwd")   // password의 name을 변경할 수 있음
                            // .failureUrl("/fail")    // 실패시 연결할 url
                            .successHandler((request, response, authentication) -> {    // 인증관련 정보를 authentication에 저장
                                // 인증에 성공했을 때 내가 하고 싶은 일을 직접 구현할 수 있음
                                System.out.println("로그인 성골 " + authentication.getName());   // 콘솔에 이름 출력
                                response.sendRedirect("/info"); // 성공하면 info로 리다이렉트
                            })
                            .failureHandler((request, response, exception) -> {
                                System.out.println("로그인 실패 " + exception.getMessage());
                                response.sendRedirect("/hello");
                            })
                    )
                    .logout(logout -> logout
                            // .logoutUrl("/logout_carami")    // POST 전용, Get 방식이 허용하는 것을 위험하다고 판단
                            .logoutSuccessUrl("/hello")
                            .addLogoutHandler((request, response, authentication) -> {
                                // 로그아웃할 때 어떤 일을 진행해야 할지
                                System.out.println("로그아웃, 세션, 쿠키도 삭제");
                                request.getSession(false).invalidate(); // 세션삭제
                            })
                            .deleteCookies("JSESSIONID")
                    )
                    .build();
        }
    }
```