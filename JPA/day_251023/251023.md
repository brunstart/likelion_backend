## 스냅샷
- 영속성 컨텍스트가 관리를 들어갈 때 DB에서 가져온 상태 그대로를 저장해놓음
- 트랜잭션 마무리 될 때 엔티티와 스냅샷을 비교해서 입력, 수정, 아무것도 안함 등 행동을 결정함
- 1차 캐시가 가지고 있음

## @GenaratedValue
- SEQUENCE : MySQL은 시퀀스 객체가 없어서 테이블을 자체적으로 만들어서 진행함

## persistence.xml
- resources/META-INF/ 에 있는 설정파일 (META-INF 없으면 생성)
- \<properties> 내 jdbc.driver, jdbc.ur, jdbc.user, jdbc.password 는 필수옵션
- ddl_auto : update 값은 운영에서는 사용하면 안되는 옵션임 (실제 업무를 할 때는 DB 설계가 되어있을것)
- persistence-unit : 공장에 대한 정보, 여러개 쓸 수 있음
  - 엔티티 추가 시 해당 엔티티를 인지하도록 <class>org.example.jpa.User</class> 추가 (자동으로 인식하게 하는 기능도 있음)

## 리팩토링
- 리팩토링 시 중요한건 테스트 코드를 만들어보고, 리팩토링 전후 같은 결과가 나오게 하는것

## flush()
- 강제적으로 실행할 때 씀 (가급적 사용하지 않는 편이 좋음)

## 엔티티 클래스
- @Entity 어노테이션 필수
- 식별자(@Id) 필수 : 각 엔티티는 유일하게 식별되는 식별자를 가져야함
- final 클래스 불가
- final 필드 제한
- id 값은 대체로 의미 없는 값을 많이 사용함

## 비영속
- 영속성 컨텍스트와 무관한 상태
## 영속
- 영속성 컨텍스트에 관리되는 상태
## 준영속
- 영속성 컨텍스트에서 분리된 상태
## 삭제
- 삭제가 예정된 상태

## 영속성 컨텍스트의 장점
- 영속성 컨텍스트가 엔티티를 관리함 -> 1L 조회 시 영속성 컨텍스트가 갖고 있으면 주고 없으면 DB에서 가져옴
- 1L 다시 조회하면 영속성 컨텍스트에서 가져옴
- 같은 트랜잭션 내 반복 조회 시 DB 접근없이 캐시에서 반환 (동일성 보장, 데이터 일관성 유지)

## EntityManagerFactory
- 전체 어플리케이션에서 하나만 있으면 되겠다는 생각, 생성 자원을 많이 먹음
- JPAUtil 클래스 생성해서 EMF 선언