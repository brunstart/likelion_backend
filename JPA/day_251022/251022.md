## JDBC 프레임워크의 종류
- Spring JDBC
- MyBatis
- JPA

## JPA (Java Persistence API)
- 자바 플랫폼의 ORM 표준 API
### 특징
- 표준화: Java EE 및 Spring에서 공식 지원하는 표준
- 구현체 독립성: Hibernate, EclipseLink 등 다양한 구현체 사용 가능
- 데이터베이스 독립성: 특정 DB에 종속되지 않음
- 생산성 향상: SQL 작성 최소화, 반복 코드 제거
- **객체 중심 개발: 데이터베이스보다 비즈니스 로직에 집중**

## JPA 변천사
- EJB라고 있었음
  - 메시지 드리블 빈
  - 세션 빈
  - 엔티티 빈 : 객체 = 테이블로 하는 개념인데 잘 안씀 -> 구현이 엉망이었음
- 엔티티 빈의 대체재로 나온게 하이버네이트
- 자바 진영에서 하이버네이트를 표준화할 필요성을 느낌 -> JPA

## ORM (Object Oriental Mapping)
- 값을 담기가 편해서 테이블 설계를 따라서 객체 설계 하는 경우가 많았음 -> 객체 지향적인 설계는 아님
- 객체는 객체대로, 관계형 DB는 DB대로 설계해서 매핑하는 기술

## 의존성 추가
```
    implementation 'org.hibernate:hibernate-core:6.4.4.Final'
    implementation 'com.mysql:mysql-connector-j:8.3.0'
    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    implementation 'org.slf4j:slf4j-simple:2.0.13'               // 둘 중 하나 택일
    implementation 'ch.qos.logback:logback-classic:1.2.11'       // 둘 중 하나 택일
    compileOnly group: 'org.projectlombok', name: 'lombok', version: '1.18.32' // 롬복 추가
```
## 자동으로 쓰려면 알려줘야할 정보가 있다 (규칙을 지켜야한다)
- 관련 정보를 persistence.xml에 넣어야 한다.

## persistence.xml
- /resources/MEAT-INF/ 디렉토리에 생성해야함
- 기본 설정
- hibernate dialect : 필수 설정, 사용하는 DB에 맞춰서 hibernate dialect를 알려줘야함, 어떤 DB의 방언을 쓸건지
- DDL auto : 테이블 생성에 관련된 옵션 (운영중에 테이블 생성 같은거로 설정하면 안됨 / 데이터 다 날아감)
- show_sql : 내가 만든 sql을 볼 수 있는 옵션
- format_sql : SQL 보여줄 때 포맷팅해서 보여주는 옵션

### persistence-unit
- 여러개 가질 수 있음
- 영속성유닛에 따라 DB 접속이 다를 수 있음

## 용어⭐
- 엔티티 매니저
- 영속성 컨텍스트
- 트랜잭션
- 엔티티

## 영속성 컨텍스트
- 원본을 사진으로 찍어놓음 (스냅샷)
- 트랜잭션이 끝날 때 스냅샷과 원본을 비교해서 같으면 아무것도 안함
- 변경 내역이 있으면 update를 실행
- 엔티티의 ID값이 있어야 영속성 컨텍스트가 관리를 할 수 있음 (@Id 어노테이션 사용)
- 엔티티 매니저 하나 당 영속성 컨텍스트 하나가 있음

## @GeneratedValue
- id필드 위에 선언되는 어노테이션 (예시 : @GeneratedValue(strategy = GenerationType.IDENTITY))
- Persistence 될 때 값이 자동으로 들어가도록 설정할 수 있음
  - GenerationType 값의 종류
  - AUTO : 알아서 함
  - IDENTITY : MySQL의 auto_increment와 같은 기능

## 영속 / 비영속 상태
- 비영속 상태 : persistence context 가 관리하지 않고 있는 상태
- 영속 상태 : persist() 를 해서 영속성 컨텍스트가 관리하고 있는 상태

## entityManager.find()
- 엔티티 매니저에게 ID 3번이 있는지 영속성 컨텍스트에게 먼저 물어봄
- 있으면 영속성 컨텍스트가 줌
- 없으면 그때 DB가서 찾음

## persist() : 영속성 컨텍스트에 저장하는것

## 영속성 컨텍스트는 언제까지 지속되는가?
- 트랜잭션이 끝날때까지
- 트랜잭션이 종료되는 시점에서 분석하고 필요한 sql을 실행함

## JPA 동작 과정
- 엔티티가 될 클래스를 작성, 엔티티는 기본 생성자가 필수
- 클래스 위에 @Entity 어노테이션 추가, 위 기능을 쓰려면 @Id를 필드위에 추가하는걸로 PK 설정을 해줘야함
- 클래스 위에 @Table(name="생성할 테이블명") 추가
- @Id로 설정한 값을 자동으로 채우고 싶을 때 @GeneratedValue(strategy = GenerationType.~) 을 사용
### ~ 에 들어가는 설정 값
- AUTO : 알아서 함
- IDENTITY : MySQL에서 쓰는 AUTO_INCREMENT 기능
- SEQUENCE : 자체적으로 테이블을 생성, 순서대로 값을 구해서 ID값에 대입
- JPA를 동작할 클래스를 작성, EntityManagerFactory 객체 생성
- createEntityManagerFactory의 매개변수는 persistence.xml에서 지정한 persistence-unit의 name값 입력
- 트랜잭션 시작
- 작업을 원하는 값 세팅
- persist() 메소드로 영속성 컨텍스트에 저장 (객체가 영속성을 가지게 됨)
- 트랜잭션 종료 (commit())

## JUnit
- 테스트 목적
- src 내 test 폴더에서 진행
- 보통 패키지명 동일하게 하고 클래스이름+Test 붙여서 파일 생성

### 테스트 시 사용하는 어노테이션
- @TestMethodOrder(MethodOrderer.OrderAnnotation.class) : @Order 어노테이션 순서에 따라 테스트를 진행하려면 추가해야 하는 어노테이션 (OrderAnnotation)
- @Order() : 테스트를 원하는 순서대로 진행하고 싶을 때 사용하는 어노테이션 (@Order(1), @Order(2), ...)
- @BeforeAll : 테스트가 실행되기 전 한 번만 실행 - 전체적인 세팅 등을 할 수 있음
- @AfterAll : 전체 테스트가 종료될 때 한 번만 실행 - 마무리 작업 진행
- @BeforeEach : 테스트 전에 실행되도록 하는 어노테이션
  - 테스트 시 마다 객체 생성을 할 필요 없음
    ```java
    Calculator calculator = null;

    @BeforeEach // 테스트 전에 실행되도록 하는 어노테이션
    public void setup() {
        calculator = new Calculator();
        System.out.println("테스트 실행 전");
    }
    ```
- @AfterEach : 테스트 후에 실행되도록 하는 어노테이션
- @Test : JUnit 프레임워크가 실행할 메서드를 표시, 없으면 테스트 케이스로 인식되지 않음
- @DisplayName() : 실행 창에 표시되는 테스트케이스의 이름을 변경해서 보여주는 어노테이션