# 250910  DataBase 실습

```sql
use liondb;         
select * from emp;   -- emp 테이블 전체 조회
select distinct job from emp;
select distinct job, empno from emp;

select job empno from emp;

select ename, sal * 18 "연봉" from emp;

select * from emp where deptno = 10;
select * from emp where job='manager';
select * from emp where sal > 2500;

select * from emp where sal > 2500 and job = 'manager';

select * from emp
where deptno = 10 or deptno = 20 or deptno = 30;
```

## IN () : () 안에 포함되는 것만 조회
```sql
select * from emp
where deptno in (10, 20, 30);
```

## NOT IN () : ()안에 포함이 안되는 것만 조회
```sql
select * from emp
where deptno not in (10, 40);
```

## BETWEEN ~ AND ~ : 두 값의 사이를 조건으로 조회 (앞에 나오는 값이 더 작아야함)
```sql
select * from emp where sal between 2300 and 3000; -- between a and b : a와 b 사이 값 조회 (a가 b보다 작아야함)
```

## 이름의 F로 시작하는 사람을 모두 구하고 싶다.
```sql
select * from emp where ename like 'F%';
```
## %의 의미(와일드카드) : 모든것을 의미(*), 0개도 포함됨


## _ : 한글자 와일드 카드
### 이름이 두번째 글자가 O인 사원을 조회한다
```sql
select * from emp where ename like '_O%';
```

## NULL 값 처리
### NULL이 아닌 값 조회
```sql
select * from emp where comm is not null;
```
### NULL일 경우의 처리
```sql
select comm, ifnull(comm, 100) from emp; -- comm이 NULL일 경우 100으로 대체

select ename, coalesce(comm, job, '모름') from emp; -- comm이 null일 경우 job, job도 null일 경우 '모름'으로 대체
```
## 정렬 (ASC | DESC) : 기본적으로  ASC(오름차순)
```sql
desc emp;
select empno, ename, job, mgr, sal from emp order by 5 asc; -- 컬럼의 순서도 정렬 기준으로 쓸 수 있다. 5번째 컬럼을 쓴다고 한것
select empno, ename, job, mgr, sal from emp order by 5 asc, ename asc; -- 조건을 여러개 쓸 수도 있음
```

## 페이징
### 한꺼번에 많은 데이터가 들어오면 시스템이 처리하기 힘듦 -> 페이징을 사용 (limit)
```sql
select empno, ename, mgr*18 연봉 from emp order by 3 limit 4;
```

### offset으로도 페이징 가능
```sql
select empno, ename, mgr*18 연봉 from emp order by 3 limit 10, 10; -- limit a, b -> a번부터 b개
```
offset이 클 경우 성능저하 발생

## SQL 함수
```sql
select upper('hello'), lower('HELLO');

select substring('Hello World', 1, 5);

select concat(ename, ' 사원님') 사원명단 from emp;

select round(3.2), ceil(3.2), floor(3.9);

select abs(-10);

select power(2, 3), sqrt(16);

select greatest(1,2,3), least(1,2,3);

select 
    curdate(),  -- 오늘 날짜
    curtime(),  -- 현재 시간
    now();      -- 날짜 + 시간

-- 날짜 포맷팅
select date_format(now(), '%Y년 %m월 %d일');

-- 날짜 연산
select
date_add(now(), interval 1 day),
date_sub(now(), interval 1 month);

-- 날짜 차이
select datediff('2024-12-31', now());

-- 날짜 부분 추출
select
    year(now()),
    month(now()),
    day(now()),
    dayofweek(now());

-- 오늘 날짜와 시간
select now();

-- 올해 연월일 구하기
select
    year(now()),
    month(now()),
    day(now());

-- 오늘부터 200일 뒤의 날짜
select date_add(now(), interval 200 day);

-- 2025년 8월 13일부터 며칠 지났는지 구하세요.
select datediff(now(), '2025-08-13');

-- 오늘 날짜를 2025년 09월 10일 과 같은 형태로 출력하세요.
select date_format(now(), '%Y년 %m월 %d일');

select date_format(hiredate, '%Y년 %m월 %d일') from emp;

-- 단일행 함수
```

## 그룹 함수
```sql
select count(ename) from emp;

SELECT count(ename) from emp;	-- 그룹함수와 일반 컬럼은 같이 나올 수 없다
select count(comm) from emp;	-- null 아닌것만 count
select count(*) from emp;

select sum(sal) from emp;

-- 부서별 급여 평균을 구하고 싶다.
select deptno, avg(sal) from emp
group by deptno;	-- 그룹핑에 참여한 컬럼은 컬럼절에 나올 수 있다. deptno 같이 조회 가능

-- 부서별, 직무별 평균을 구하고 싶다.
select job, avg(sal) from emp
group by job;

select deptno, job, avg(sal) from emp
group by deptno, job
order by 1, 2;

-- 조건 where : 전체에 대한 조건
-- 조건 having : 그룹핑 된 결과에 대한 조건

-- 10번 부서 제외 모든 사원의 부서별, 직무별 평균 급여 (전체 조건 -> where)
-- 평균 급여가 3000이상인 결과는 제외 (그룹핑 결과에 대한 조건 -> having)
select deptno, job, avg(sal) 평균급여
from emp
where deptno != 10
group by deptno, job
having 평균급여 < 3000
order by 1, 2;
```
## JOIN : 하나 이상의 테이블로부터 연관된 데이터를 검색해오는 방법
### 연결하려는 테이블 -1개만큼은 JOIN 조건이 있어야함
```sql
-- SIMPLE JOIN (전통적인 JOIN 방식)
SELECT
    e.first_name,
    e.last_name,
    d.department_name
FROM
    employees e,
    departments d
WHERE
    e.department_id = d.department_id;

-- ANSI JOIN
-- JOIN ~ USING 동일한 컬럼명을 사용하고 있는 경우
select e.ename, e.sal, d.deptno, d.dname
from emp e join dept d using(deptno);

-- JOIN ~ ON
SELECT
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;
```
