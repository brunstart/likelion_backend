## Static
- 객체를 메모리에 미리 올려놓는 키워드
- 인스턴스와 범위가 다름
- 스태틱 안에서 인스턴스 변수 참조 불가

## 메소드 오버로딩
- 동일한 기능의 함수에서 다양한 매개변수를 받도록 구현

## this()
- 자기자신의 객체를 가리키는 단어

## 추상화
- 가급적 비슷하게 객체들을 도출해보는게 중요.

## 상속
- **일반화**와 **확장**의 개념을 합친 것
- 부모가 가진 속성과 기능을 그대로 물려 받는 것
- JAVA는 단일상속 (다중상속X)
### 1. 부모(조상)은 자식(자손)을 가리킬 수 있다 (반대는 불가)
```java
    Parent p = new Child(); // 문제 없음
    Child c = new Parent(); // 오류 발생
```
### 2. 필드는 타입을 따른다
```java
    Parent1 pp = new Parent1();
    System.out.println(pp.i);   // 부모의 i 출력
    Child1 cc = new Child1();
    System.out.println(cc.i);   // 자식의 i 출력
    Parent1 pc = new Child1();
    System.out.println(pc.i);   // 부모의 i 출력
```
### ***3. 메소드는 오버라이드되면 무조건 자식의 것을 사용한다 (핵심)***
- ### 오버라이딩
    - 부모가 가진 것을 자식이 다시 재정의 하는것

## 형변환
```java
        Parent1 p = new Child1();
//        형변환 - 작은 그릇에서 큰 그릇으로 바꿀 때 (묵시적 형변환 가능)
//        큰 그릇 : Parent1, 작은 그릇 : Child1

        Object obj = p;     // 묵시적 형변환 (Object는 가장 큰 객체)
        //p = obj;          // 큰 그릇으로 옮겨 담은 후 다시 작은 그릇으로 옮겨 담을 때 오류 발생
        p = (Parent1) obj;  // 명시적 형변환

        Child1 c = (Child1) p;  // 가능

        Parent1 pp = new Parent1();

//        형변환시에는 인스턴스가 중요
//        p는 Child1 인스턴스라서 형변환이 가능
//        pp는 인스턴스 자체가 Parent1이라서 Child1으로 형변환 불가

//        Child1 cc = (Child1) pp;    // 오류는 없지만 실행 불가

        if (pp instanceof Child1){     // pp의 인스턴스가 Child1인지 검사하고 맞다면 형변환
            Child1 cc = (Child1) pp;
        }
```
- 상속 관계에 있는 객체들끼리만 형변환이 가능


## instanceof
- 인스턴스를 비교하는 연산자

## super
- super : 부모 클래스의 멤버에 접근
- super() : 부모 클래스의 생성자 호출
```java
class Parent3{
    int i = 10;

    public void print()
    {
        System.out.println("parent : " + i);
    }

    public Parent3(){
        System.out.println("Parent3");
    }

    public Parent3(int i)
    {
        System.out.println("Parent3 int");
    }
}

class Child3 extends Parent3{
    int i = 20;

    public void print(){
        super.print();
        System.out.println("child : " + i);
    }

    public Child3(){
        System.out.println("Child3");   
    }

    public Child3(int i)
    {
        System.out.println("Child3 int");
    }

    public int getI(){
        return i;
    }
}

public class SuperExam {
    public static void main(String[] args) {
//        Parent3 parent3 = new Parent3();
        Child3 c = new Child3(10);

        System.out.println(c.i);
        System.out.println(c.getI());
        c.print();
    }
}
```
-> 상속받은 객체의 생성자 호출 시 기본적으로 부모의 default 생성자를 호출  
따라서 위 코드를 실행하면 Parent3() 생성자, Child3(int i) 생성자가 호출됨


- super()로 부모의 생성자에 접근 가능
- 모든 생성자는 첫 줄에 super() 또는 this() 호출
- 명시하지 않을 경우 자동으로  super() 호출
- 부모의 디폴트 생성자가 없을 경우 다른 생성자를 **반드시** 명시적으로 호출해야함


## 인스턴스 형변환
```java
//        필드는 타입을 따른다
        Parent3 p = new Child3();    // Child3 클래스에는 childMethod 메소드가 있음
//        p.childMethod();           // Child3 인스턴스인데 childMethod를 못쓰는 이유
//                                      chileMethod를 갖고는 있지만 타입이 Parent3이기 때문에 자신이 물려준것만 사용가능
        ((Child3)p).childMethod();   // 이 때 Child3로 형변환을 해주면 childMethod를 사용이 가능
```

## 메소드 오버라이딩
- 부모 클래스의 메소드를 자식 클래스에서 재정의
- 메소드 이름, 매개변수, 반환 타입이 **동일**해야 함
- @Override 어노테이션 사용 권장

## 다형성
- 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이  
다양한 자료형(type)에 속하는 것이 허가되는 성질
- 껍데기는 하나인데 구현이 여러개인것
```java
    class Bird{
        public void sing()
        {
            
        }
    }
    
    class sparrow extends Bird
    {
        @Override
        public void sing()
        {
            System.out.println("짹짹");
        }
    }
    
    class pigeon extends Bird
    {
        @Override
        public void sing()
        {
            System.out.println("구구");
        }
    }

    public static void main(String[] args) {
        Bird s = new Sparrow();
        b.sing();       // 짹짹 출력
        
        Bird p = new Pigeon();
        p.sing();       // 구구 출력
    }

```
- 부모클래스 Bird에 sing 메소드가 있고, 자식클래스 sparrow, pigeon에서  
sing 메소드를 오버라이딩 해서 각각 짹짹, 구구가 출력됨.
- sing 메소드 하나로 짹짹과 구구 출력 두가지 결과를 구현한 것

## 필드
- 필드는 대체로 접근제한자 private을 일반적으로 사용
- 직접적인 필드 수정을 막고, 대신 접근은 메소드를 통해 허용 (getter, setter)
